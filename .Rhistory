euler(
pos_neg_1_vd <- list(
"700" = 301:1000,
"35" = 301:335,
"300" = 1:300,
"15" = 1:15
),
shape = "ellipse"
),
fills = list(
fill = c(
"dark green", # Positive
"purple",      # False Negative
"light blue",  # Negative
"red"          # False positive
),
alpha = 0.5
),
)
# FDR comparison
fdr_1_plot <- plot(
euler(
list(
"True Positives" = 336:1000,
"False Positives" = 1:15
),
shape = "ellipse"
),
fills = list(
fill = c(
"green", # Positive
"red"          # False Positive
),
alpha = 0.5
),
labels = c(
665,
15
)
)
# 500 positives vs. 500 negatives
# Overview
pos_neg_2_plot <- plot(
euler(
list(
"500 " = 501:1000,
"25 " = 501:525,
"500" = 1:500,
"25" = 1:25
),
shape = "ellipse"
),
fills = list(
fill = c(
"dark green", # Positive
"purple",      # False Negative
"light blue",  # Negative
"red"          # False positive
),
alpha = 0.5
)
)
#FDR
fdr_2_plot <- plot(
euler(
list(
"True Positives" = 526:1000,
"False Positives" = 1:25
),
shape = "ellipse"
),
fills = list(
fill = c(
"green", # Positive
"red"          # False Positive
),
alpha = 0.5
),
labels = c(
475,
25
)
)
# 200 positives vs. 800 negatives
pos_neg_3_plot <-plot(
euler(
list(
"300" = 701:1000,
"15" = 701:715,
"700" = 1:700,
"35" = 1:35
),
shape = "ellipse"
),
fills = list(
fill = c(
"dark green", # Positive
"purple",      # False Negative
"light blue",  # Negative
"red"          # False positive
),
alpha = 0.5
)
)
fdr_3_plot <- plot(
euler(
list(
"Positives" = 811:1000,
"False Positives" = 1:40
),
shape = "ellipse"
),
fills = list(
fill = c(
"green", # Positive
"red"          # False Positive
),
alpha = 0.5
),
labels = c(
190,
40
)
)
library(ggplot2)
library(ggpubr)
ggarrange(
pos_neg_1_plot,
fdr_1_plot,
pos_neg_2_plot,
fdr_2_plot,
pos_neg_3_plot,
fdr_3_plot,
ncol = 2,
nrow = 3,
labels = c("Sample","FDR")
)
library(eulerr)
set.seed(7)
# Overview
pos_neg_1_plot <- plot(
euler(
pos_neg_1_vd <- list(
"700" = 301:1000,
"35" = 301:335,
"300" = 1:300,
"15" = 1:15
),
shape = "ellipse"
),
fills = list(
fill = c(
"dark green", # Positive
"purple",      # False Negative
"light blue",  # Negative
"red"          # False positive
),
alpha = 0.5
),
)
# FDR comparison
fdr_1_plot <- plot(
euler(
list(
"True Positives" = 336:1000,
"False Positives" = 1:15
),
shape = "ellipse"
),
fills = list(
fill = c(
"green", # Positive
"red"          # False Positive
),
alpha = 0.5
),
labels = c(
665,
15
)
)
# 500 positives vs. 500 negatives
# Overview
pos_neg_2_plot <- plot(
euler(
list(
"500 " = 501:1000,
"25 " = 501:525,
"500" = 1:500,
"25" = 1:25
),
shape = "ellipse"
),
fills = list(
fill = c(
"dark green", # Positive
"purple",      # False Negative
"light blue",  # Negative
"red"          # False positive
),
alpha = 0.5
)
)
#FDR
fdr_2_plot <- plot(
euler(
list(
"True Positives" = 526:1000,
"False Positives" = 1:25
),
shape = "ellipse"
),
fills = list(
fill = c(
"green", # Positive
"red"          # False Positive
),
alpha = 0.5
),
labels = c(
475,
25
)
)
# 200 positives vs. 800 negatives
pos_neg_3_plot <-plot(
euler(
list(
"300" = 701:1000,
"15" = 701:715,
"700" = 1:700,
"35" = 1:35
),
shape = "ellipse"
),
fills = list(
fill = c(
"dark green", # Positive
"purple",      # False Negative
"light blue",  # Negative
"red"          # False positive
),
alpha = 0.5
)
)
fdr_3_plot <- plot(
euler(
list(
"Positives" = 716:1000,
"False Positives" = 1:35
),
shape = "ellipse"
),
fills = list(
fill = c(
"green", # Positive
"red"          # False Positive
),
alpha = 0.5
),
labels = c(
285,
35
)
)
library(ggplot2)
library(ggpubr)
ggarrange(
pos_neg_1_plot,
fdr_1_plot,
pos_neg_2_plot,
fdr_2_plot,
pos_neg_3_plot,
fdr_3_plot,
ncol = 2,
nrow = 3,
labels = c("Sample","FDR")
)
fdr_df <- data.frame(
pop_pos  = c(700,500,300),
pop_neg  = c(300,500,700),
power    = c(.95,.95,.95),
alpha    = c(.05,.05,.05)
)
fdr_df$true_pos  = fdr_df$pop_pos * fdr_df$power
fdr_df$true_neg  = fdr_df$pop_neg * (1- fdr_df$alpha)
fdr_df$false_pos = fdr_df$pop_neg * fdr_df$alpha
fdr_df$false_neg = fdr_df$pop_pos * (1-fdr_df$power)
fdr_df$FDR       = fdr_df$false_pos/(fdr_df$false_pos + fdr_df$true_pos)
knitr::kable(fdr_df)
#| label: fig-fp-vs-neg
#| fig-cap: A visualisation of simulations that show the effect of the proportion of positive effects in the population on what proportion of negative findings that will become false-positives.
ggplot(
data = fwer_summary_mean_se,
aes(
x=positive_prop,
y=fwer_mean,
fill=as.factor(positive_prop))
) +
geom_col() +
geom_errorbar(aes(ymin = fwer_mean - fwer_sd, ymax = fwer_mean + fwer_sd)) +
xlab("Proportion of the population that is positive") +
ylab("FWER per 100 simulations")
# identifying if any simulation had at least one false positive to identify FWER as 1 or 0
fwer_sim_df$hb_fwer = ifelse(fwer_sim_df$hb_fp > 0, 1 , 0)
options(scipen = 999)
# calculate how many participants are needed
this_effect_size = 1
sim_pwr   = pwr::pwr.t.test(
d = this_effect_size,
sig.level = .05,
power = .95
)
this_pp   = round(sim_pwr$n)
n_tests  = 500
# preparing data frame for all the simulations
fwer_sim_df <- data.frame(
positive_prop = rep(c(1,3,5,7,9), n_tests)/10,
pop_pos = NA,
pop_neg = NA,
samp_pos = NA,
samp_neg = NA,
fwer = NA
)
tests_per_sim = 100
for(i in 1:length(fwer_sim_df$positive_prop)){
# prepare a data frame to compare positive and negatives within a sample compared to the population
this_subset = data.frame(
population = rep("",tests_per_sim),
sample     = "",
true_false = FALSE,
p.value    = NA
)
this_pos_prop = fwer_sim_df$positive_prop[i]
for(k in 1:tests_per_sim){
# if the population is positive
if(k/tests_per_sim <= this_pos_prop){
this_subset$population[k] = "positive"
this_t_test <- t.test(
rnorm(
this_pp,
mean = this_effect_size,
sd = 1
),
mu = 0
)
this_subset$p.value[k] <- this_t_test$p.value
}
#if the population is negative
if(k/tests_per_sim > this_pos_prop){
this_subset$population[k] = "negative"
this_subset$p.value[k] = runif(1,min = 0,max = 1)
}
}
# sort the subset into appropriate ranks
this_subset %>%
arrange(p.value) -> sorted_subset
sorted_subset$rank = rank(sorted_subset$p.value)
## FWER using HS (Holm-Šidák)
hb_tp = 0
hb_tn = 0
hb_fp = 0
hb_fn = 0
valid_alpha = TRUE
hb_max_alpha = NA
for(j in 1:tests_per_sim){
this_alpha = 1 - (1-.05)^(1/(tests_per_sim + 1 - j))
# positive
if(sorted_subset$p.value[j] < this_alpha & valid_alpha){
# true
if(sorted_subset$population[j] == "positive"){
hb_tp = hb_tp + 1
} else if(sorted_subset$population[j] == "negative"){
hb_fp = hb_fp + 1
}
hb_max_alpha = this_alpha
} else {
valid_alpha = FALSE
if(sorted_subset$population[j] == "positive"){
hb_fn = hb_fn + 1
} else if(sorted_subset$population[j] == "negative"){
hb_tn = hb_tn + 1
}
}
}
fwer_sim_df$hb_tp[i]        = hb_tp
fwer_sim_df$hb_fp[i]        = hb_fp
fwer_sim_df$hb_tn[i]        = hb_tn
fwer_sim_df$hb_fn[i]        = hb_fn
fwer_sim_df$hb_max_alpha[i] = hb_max_alpha
}
# identifying if any simulation had at least one false positive to identify FWER as 1 or 0
fwer_sim_df$hb_fwer = ifelse(fwer_sim_df$hb_fp > 0, 1 , 0)
# allocating simulations into sets of 100
fwer_sim_df$sim_group = rep(1:25, each = 100)
fwer_summary <- fwer_sim_df %>%
group_by(positive_prop, sim_group) %>%
summarise(
.groups = "keep",
fwer = mean(hb_fwer)
)
fwer_summary_mean_se <- fwer_summary %>%
group_by(positive_prop) %>%
summarise(
fwer_mean = mean(fwer),
fwer_sd = sd(fwer)
)
#| label: fig-fp-vs-neg
#| fig-cap: A visualisation of simulations that show the effect of the proportion of positive effects in the population on what proportion of negative findings that will become false-positives.
ggplot(
data = fwer_summary_mean_se,
aes(
x=positive_prop,
y=fwer_mean,
fill=as.factor(positive_prop))
) +
geom_col() +
geom_errorbar(aes(ymin = fwer_mean - fwer_sd, ymax = fwer_mean + fwer_sd)) +
xlab("Proportion of the population that is positive") +
ylab("FWER per 100 simulations")
15/36
#| label: fig-binomial-coin-outcomes
#| fig-cap: Description will be here
library(ggplot2)
d=data.frame(
x1=c(0,  .5,0, .5),
x2=c(0.5,1 ,.5,1),
y1=c(0,  .5,.5,0),
y2=c(0.5,1 ,1 ,.5),
# t=c('Both heads','Both tails','Mixed','Mixed'),
r=c('Both heads','Both tails','Mixed','Mixed'))
ggplot() +
scale_x_continuous(name="Flip 1") +
scale_y_continuous(name="Flip 2") +
geom_rect(data=d, mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2, fill=r), color="black", alpha=0.5) +
geom_text(data=d, aes(x=x1+(x2-x1)/2, y=y1+(y2-y1)/2, label=r), size=4)
biased_coin_flips <- data.frame(
first_flip = c("heads","heads","tails","tails"),
first_likelihood = c(.75,.75,.25,.25),
second_flip = c("heads","tails","heads","tails"),
second_likelihood = c(.75,.25,.75,.25)
)
biased_coin_flips <- data.frame(
first_flip = c("heads","heads","tails","tails"),
first_likelihood = c(.75,.75,.25,.25),
second_flip = c("heads","tails","heads","tails"),
second_likelihood = c(.75,.25,.75,.25)
)
biased_coin_flips$outcome_likelihood = biased_coin_flips$first_likelihood * second_likelihood
biased_coin_flips <- data.frame(
first_flip = c("heads","heads","tails","tails"),
first_likelihood = c(.75,.75,.25,.25),
second_flip = c("heads","tails","heads","tails"),
second_likelihood = c(.75,.25,.75,.25)
)
biased_coin_flips$outcome_likelihood = biased_coin_flips$first_likelihood *
biased_coin_flips$second_likelihood
sum(biased_coin_flips$outcome_likelihood)
knitr::kable(biased_coin_flips)
biased_coin_flips <- data.frame(
first_flip = c("heads","heads","tails","tails"),
first_likelihood = c(.75,.75,.25,.25),
second_flip = c("heads","tails","heads","tails"),
second_likelihood = c(.75,.25,.75,.25),
heads = c(2,1,1,0)
)
biased_coin_flips$outcome_likelihood = biased_coin_flips$first_likelihood *
biased_coin_flips$second_likelihood
# Checking if all outcomes captured (should get 1) and no overlapping outcomes (should not get more than 1). See the page on *probabilities* for more information
sum(biased_coin_flips$outcome_likelihood)
knitr::kable(biased_coin_flips)
biased_heads <- data.frame(
heads = c(0,1,2),
freq  = c(
biased_coin_flips$outcome_likelihood[biased_coin_flips$heads == 0],
biased_coin_flips$outcome_likelihood[biased_coin_flips$heads == 1],
biased_coin_flips$outcome_likelihood[biased_coin_flips$heads == 2]
)
)
biased_heads <- data.frame(
heads = c(0,1,2),
freq  = c(
sum(biased_coin_flips$outcome_likelihood[biased_coin_flips$heads == 0]),
sum(biased_coin_flips$outcome_likelihood[biased_coin_flips$heads == 1]),
sum(biased_coin_flips$outcome_likelihood[biased_coin_flips$heads == 2])
)
)
biased_heads
ggplot(biased_heads, aes(x=heads,y=freq)) +
geom_bar()
ggplot(biased_heads, aes(x=heads,y=freq)) +
geom_col()
sum(biased_coin_flips$heads >= 1) / length(biased_coin_flips$heads)
ggplot(biased_coin_flips, aes(heads, fill = heads >= 1)) + geom_histogram(bins = 3)
ggplot(biased_coin_flips, aes(heads, fill = heads >= 1)) + geom_histogram(bins = 3)
ggplot(biased_heads, aes(x=heads,y=freq, fill = heads >= 1)) +
geom_col() +
xlab("Number of head flips") +
ylab("Frequency")
sum(biased_heads$heads >= 1)
sum(biased_heads$freq[biased_heads$heads >= 1])
ggplot(biased_heads, aes(x=heads,y=freq, fill = heads >= 1)) +
geom_col() +
xlab("Number of head flips") +
ylab("Frequency")
#| label: fig-binomial-biased-coin-distribution
#| fig-cap: a binomial distribution reflecting how likely it you will flip head at least once when the coin has a .75 bias for heads.
ggplot(biased_heads, aes(x=heads,y=freq, fill = heads >= 1)) +
geom_col() +
xlab("Number of head flips") +
ylab("Frequency")
reticulate::repl_python()
