{
  "hash": "789939ac50cadbe49361c54db24ef2ec",
  "result": {
    "markdown": "---\ntitle: \"Normal Distribution\"\nformat: html\neditor: visual\n---\n\n\n## Bell curve (AKA normal distribution)\n\n**Parametric statistics** often compare values to a **normal** distribution of **expected data**, based on the **estimated mean and SD**. Lets start by showing a (made up) **normal** distribution of heights in centimeters:\n\nSo lets say the average person's height is 150cm, and the standard deviation of height across the population is 10cm. The data would look something like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot a normal distribution of heights\npopulation_heights_x <- seq(\n  120,    # min\n  180,    # max\n  by = 1  \n)\npopulation_heights_y <- dnorm(\n  population_heights_x,\n  mean = 150,\n  sd   = 10\n)\nplot(\n  population_heights_x,\n  population_heights_y,\n  xlab = \"height\",\n  ylab = \"frequency\"\n)\n# Add line to show mean and median\nabline(\n  v=150,  # where the line for the mean will be \n  lwd=5\n)\n```\n\n::: {.cell-output-display}\n![](normal_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nYou can see that the above fits a **bell-curve**, and the line in the middle represents both the **mean** and the **median** as the data is symmetrical. In reality, almost no data is a perfect bell-curve, but there are ways to test if the data isn't sufficiently normal to use parametric tests with.\n\nNext, we will look at how normal distributions allow you to transform your data to z-scores to compare to a z-distribution.\n\n## Z-scores and the z-distribution\n\nA **z-score** is a **standardised** value that captures how many standard deviations above or below the mean an individual value is. Thus, to calculate the z-score\n\n$$\nZ = \\frac{individualScore-averageScore}{StandardDeviation}\n$$\n\nOr in formal terminology:\n\n$$\nZ = \\frac{x-\\bar{x}}{\\sigma}\n$$\n\nThe calculated score can then be applied to a z-distribution, which is parametric/normally distributed. Lets have a look at a z-distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vector for the x-axis\nz_score_x <- seq(\n  -3,    # min\n  3,    # max\n  by = .1  \n)\n\n# vector for the y-axis\nz_score_y <- dnorm(\n  z_score_x,\n  mean = 0,\n  sd   = 1\n)\n\nplot(\n  z_score_x,\n  z_score_y,\n  xlab = \"z-score (SDs from the mean)\",\n  ylab = \"frequency\"\n)\n```\n\n::: {.cell-output-display}\n![](normal_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nIf you compare the height distribution above to the z-score distribution, you should see that they are identically distributed. This is useful, as we know what percentage of a population fits within each standard deviation of a normal distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n# https://stackoverflow.com/a/12429538\nnorm_x<-seq(-4,4,0.01)\nnorm_y<-dnorm(-4,4,0.0)\n\nnorm_data_frame<-data.frame(x=norm_x,y=dnorm(norm_x,0,1))\n\n\nshade_50 <- rbind(\n  c(0,0), \n  subset(norm_data_frame, x > 0), \n  c(norm_data_frame[nrow(norm_data_frame), \"X\"], 0))\n\nshade_34.1 <- rbind(\n  c(1,0), \n  subset(norm_data_frame, x > 1), \n  c(norm_data_frame[nrow(norm_data_frame), \"X\"], 0))\n\n\nshade_13.6 <- rbind(\n  c(2,0), \n  subset(norm_data_frame, x > 2), \n  c(norm_data_frame[nrow(norm_data_frame), \"X\"], 0))\n\n\np<-qplot(\n  x=norm_data_frame$x,\n  y=norm_data_frame$y,\n  geom=\"line\"\n)\n\n p +\n   \n   geom_polygon(\n     data = shade_50,\n     aes(\n       x,\n       y,\n       fill=\"50\"\n      )\n    ) +\n   geom_polygon(\n     data = shade_34.1,\n     aes(\n       x,\n       y,\n       fill=\"34.1\"\n      )\n    ) +\n   geom_polygon(\n     data = shade_13.6, \n     aes(\n       x, \n       y,\n       fill=\"13.6\"\n      )\n    ) +\n   \n   annotate(\n     \"text\", \n     x=0.5, \n     y=0.01, \n     label= \"34.1%\"\n   ) + \n   annotate(\n     \"text\", \n     x=1.5, \n     y=0.01, \n     label= \"13.6%\"\n   ) + \n   annotate(\n     \"text\", \n     x=2.3, \n     y=0.01, \n     label= \"2.3%\"\n   ) +\n   xlab(\"Z-score\") +\n   ylab(\"Frequency\") +\n   theme(legend.position=\"none\")\n```\n\n::: {.cell-output-display}\n![](normal_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThe above visualises how 34.1% of a population's scores will be between 0 and 1 standard deviation from the mean, 13.6% of the population's scores will be between 1-2 standard deviations from the mean, and 2.3% of the population will be more then 2 standard deviations from the mean. **Remember** that the normal distribution is symmetrical, so we also know that 34.1% of the population's score will be between -1 to 0 standard deviations from the mean, 13.6% of the population's score will be between -2 to -1 standard deviations from the mean, and 2.3% of the population's score will be more negative than -2 standard deviations from the mean. Lets look at this cumulative distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# https://stackoverflow.com/a/12429538\nnorm_x<-seq(-4,4,0.01)\nnorm_y<-dnorm(-4,4,0.0)\n\nnorm_data_frame<-data.frame(x=norm_x,y=dnorm(norm_x,0,1))\n\n\nshade_2.3 <- rbind(\n  c(-8,0), \n  subset(norm_data_frame, x > -8), \n  c(norm_data_frame[nrow(norm_data_frame), \"X\"], 0))\n\nshade_13.6 <- rbind(\n  c(-2,0), \n  subset(norm_data_frame, x > -2), \n  c(norm_data_frame[nrow(norm_data_frame), \"X\"], 0))\n\nshade_34.1 <- rbind(\n  c(-1,0), \n  subset(norm_data_frame, x > -1), \n  c(norm_data_frame[nrow(norm_data_frame), \"X\"], 0))\n\nshade_50 <- rbind(\n  c(0,0), \n  subset(norm_data_frame, x > 0), \n  c(norm_data_frame[nrow(norm_data_frame), \"X\"], 0))\n\nshade_84.1 <- rbind(\n  c(1,0), \n  subset(norm_data_frame, x > 1), \n  c(norm_data_frame[nrow(norm_data_frame), \"X\"], 0))\n\n\nshade_97.7 <- rbind(\n  c(2,0), \n  subset(norm_data_frame, x > 2), \n  c(norm_data_frame[nrow(norm_data_frame), \"X\"], 0))\n\n\np<-qplot(\n  x=norm_data_frame$x,\n  y=norm_data_frame$y,\n  geom=\"line\"\n)\n\n p +\n   geom_polygon(\n     data = shade_2.3,\n     aes(\n       x,\n       y,\n       fill=\"2.3\"\n      )\n    ) +\n   geom_polygon(\n     data = shade_13.6,\n     aes(\n       x,\n       y,\n       fill=\"13.6\"\n      )\n    ) +\n   geom_polygon(\n     data = shade_34.1,\n     aes(\n       x,\n       y,\n       fill=\"34.1\"\n      )\n    ) +\n   geom_polygon(\n     data = shade_50,\n     aes(\n       x,\n       y,\n       fill=\"50\"\n      )\n    ) +\n   geom_polygon(\n     data = shade_84.1,\n     aes(\n       x,\n       y,\n       fill=\"84.1\"\n      )\n    ) +\n   geom_polygon(\n     data = shade_97.7, \n     aes(\n       x, \n       y,\n       fill=\"97.7\"\n      )\n    ) +\n   xlim(c(-4,4)) +\n   \n   annotate(\"text\", x=-2.3, y=0.01, label= \"13.6%\") + \n   annotate(\"text\", x=-1.4, y=0.01, label= \"34.1%\") + \n   annotate(\"text\", x=-0.3, y=0.01, label= \"50%\") + \n   annotate(\"text\", x=0.5, y=0.01, label= \"84.1%\") + \n   annotate(\"text\", x=1.5, y=0.01, label= \"97.7%\") + \n   annotate(\"text\", x=2.3, y=0.01, label= \"100%\") +\n   xlab(\"Z-score\") +\n   ylab(\"Frequency\") +\n   theme(legend.position=\"none\")\n```\n\n::: {.cell-output-display}\n![](normal_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nThe above figure visualises how 13.6% of the population have score that is more negative than -2 standard deviations from the mean, 34.1% of the population have a standard deviation that is more negative than -1 standard deviations from the mean (this also include all the people who are more than -2 standard deviations from the mean), etc.\n\nWe can now use the above information to identify which percentile an individual is within a distribution.\n\nFor example, let's imagine that an individual called Jane wants to know what percentile she's at with her height. Lets imagine she is 170cm tall, the mean height of people 150cm, and the SD 10cm. That would make her z-score:\n\n$$\nZ_{score} = \\frac{170 - 150}{10} = 2\n$$\n\nAs we can see from the figure above, that puts her above 97.7% of the population, putting her in the top 2.3%.\n",
    "supporting": [
      "normal_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}