---
title: "Python Logic"
format: html
editor: visual
---

## Greater and less than using \> and \<

If you want to see if one **object** is larger than (\>) or smaller (\<) than another object, you can use the \> and \< operators:

```{python}
1 > 2
```

Unsurprising that the above is false, as 1 is **not greater than** 2. Lets double check if 1 is less than 2:

```{python}
1 < 2
```

## Comparing values using ==

If you want to see if 2 **objects** are the same, then you can use ==. Lets check if 1 is the same as 2:

```{python}
2 == 1
```

Unsurprisingly, 2 is not the same as 1. Lets see if 3/2 is the same as 1.5:

```{python}
3/2 == 1.5
```

Great! What you're more likely to want to do is to compare a list to a value. So let's imagine that you have asked your participants a question, and have a **list** that identifies whether someone got an answer correct or not. Let's compare that list to the word "correct":

```{python}
import numpy as np
correct_vector = np.array(["correct", "incorrect", "correct"])
correct_vector == "correct"
```

This creates an **logical vector** of **TRUE** and **FALSE** values. Let's use this now to select data:

## Indexing/Selecting data

Sometimes you want to only focus on certain data, and **indexing** is a way to do this. We're now going to create a data frame for a participant who has completed 3 trials of a reaction time task. This will include whether they were correct or not, and what their response time is. We will then using indexing to select the response times when the participant was correct:

```{python}
# load the markdownTable module 
from markdownTable import markdownTable
import pandas as pd

response_table ={'accuracy': correct_vector,
  'response_times': [100, 105, 180]}
  
response_table = pd.DataFrame(response_table)

response_table

# create an index using the logical "same as" operator
response_table["response_times"][response_table["accuracy"]=="correct"]
```

Indexing is useful to remove unwanted data. In this case, most researchers think that response times when a participant makes an invalid response are not very informative, so they remove those response times using indexing above.

## ! to reverse logic

Sometimes you'll want to flip the logic so that you get a FALSE when it would be TRUE, or TRUE when it would be FALSE. To do this, put in either a != instead of ==:

```{python}
1 != 2
```

or a ! before the logical object or statement that you want to reverse:

```{python}
[i for i, x in enumerate(correct_vector) if x == "correct"]
[i for i, x in enumerate(correct_vector) if x != "correct"]
```

## And using &

If you want to get a TRUE outcome only if multiple statements are all TRUE, then you can use the "&" operator. Lets imagine you want to only focus on responses in your data that are correct AND quick enough i.e. less than 1000ms:

```{python}
response_table["response_times_vector"] = np.array([1200,600,800])
response_table.loc[(response_table['response_times_vector']<1000) & (response_table['accuracy']=='correct')]
```

So only the third response was both correct and quick enough.

## OR using \|

OR statements can be used to get a TRUE outcome if at least one of the logical statements is TRUE. Lets imagine that you were trying to select a subset of participants who either were colorblind or wore glasses. Your data might look like this:

```{python}
eyesight_data ={
  "participant_number" : [1,2,3,4,5],
  "eyesight"           : ["colorblind","colorblind","uncorrected","uncorrected","glasses"]
}
eyesight_data = pd.DataFrame(eyesight_data)

eyesight_data
```

If we just wanted the rows that had people who were colorblind or wore glasess, we could create the following logical vector:

```{python}
eyesight_data.loc[(eyesight_data['eyesight']=="colorblind") | (eyesight_data['eyesight']=='glasses')]
```
